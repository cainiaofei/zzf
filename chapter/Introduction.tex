\chapter{绪言}

\section{研究背景}
软件可追踪性是指在软件开发过程中建立和维护软件制品之间的关联关系，并利用这些关系对软件项目进行一系列分析的能力~\cite{coest}。我们把这种关联关系成为追踪线索。在软件开发过程中，会产生各种软件制品，包括需求文档、软件架构、设计文档、用户手册和源代码等~\cite{Chen2011combining}。 这些软件制品之间的追踪关系对软件利益相关者有重要价值。不同软件制品之间的追踪关系可以使得软件工程师更好的理解系统，保证软件的质量。同时也可以降低软件维护成本，有利于软件后期的维护和演化~\cite{antoniol2002recovering,Antoniol2000Modelling,Rempel2017Defects}。 因此，软件可追踪性研究成为了当前软件工程领域的研究热点。

需求是软件系统中唯一记录了人对于完整系统功能的理解与期望的软件制品~\cite{Cleland-Huang2013Requirements}，而代码则是当前软件系统运行时行为的唯一真实反映，因此两者之间的关联关系是软件开发与维护人员最关注的。M\"ader等人通过对照实验发现，对于软件维护工作而言，在需求到代码可追踪性的支持下，维护的正确率提高了60\%，效率提高了21\%~\cite{mader2012assessing}。事实上，需求到代码的追踪数据描述了软件高层抽象和底层代码实现之间的对应关系。软件迭代过程中，当需求发生变更时，根据需求到代码的追踪数据可以快速找到要更新的代码位置。此外需求到代码的追踪信息可以应用于软件生命周期以支持变更影响分析、依赖影响分析、系统验证以及安全认证等活动~\cite{Huang2014Software,Antoniol2017Ten}。
然而，建立和维护需求到代码的追踪关系会耗费用户大量的精力并且很容易出错~\cite{ramesh2001toward}。在工业环境中，由于软件系统复杂度高，迭代速度快，这使得人工的建立和维护需求到代码的追踪关系因代价高昂被很多组织放弃~\cite{gotel1994analysis,ramesh2001toward}。因此，如何自动化的生成需求到代码元素之间的追踪关系成为了当前研究领域内的首要目标。

\begin{comment}当前领域内建立需求到代码追踪关系的主要方法是信息检索方法（~Information Retrieve），但是此类方法严重依赖需求文档和代码文档的文本质量，生成的追踪数据质量不高。为解决这个问题，众多研究工作提出了一系列增强策略。其中以下两类增强策
略是当前领域内的研究热点。有些研究者提出在信息检索方法的基础上考虑代码结构信息，但是该类方法往往受信息检索结果质量的影响~\cite{mcmillan2009combining,Kuang2017closeness}。
另一种主流的增强策略是引入用户反馈信息，但是此类方法往往需要大量的用户参与~\cite{hayes2006advancing,Lucia2006Incremental,panichella2013and}难以应用到日常实践中。
 %因此，如何高效的生成高质量软件可追踪数据是当前领域内研究的重点。
\end{comment}

\section{研究现状}

当前领域内建立需求到代码追踪关系的主要方法是信息检索方法（~Information ~Retrieve），该方法认为如果有多个词项同时存在于需求和代码文本中，则这两个软件制品很可能是描述了相同的概念或功能，即两者存在追踪关系。该方法计算需求和代码之间的文本相似度并按照该值自大到小的顺序对候选追踪线索进行排序形成候选追踪线索列表~\cite{antoniol2002recovering,hayes2006advancing,marcus2003recovering,cleland2005utilizing}。用户自上而下扫描列表，判断候选追踪线索的相关性。
%当用户连续遇到多条无效候选追踪线索，用户会终止判断，丢默认剩下的追踪线索全部无效。
表~\ref{T:IRCandidateListInIntroduction} 为一个候选追踪线索列表。表中每一行代表一条追踪线索，class 列为代码元素，req 列为需求元素，score 列为需求和代码之间的文本相似度。isTrace列为用户对改候选追踪线索的判断结果，‘X’ 表示该候选追踪线索对应的需求和代码元素具备相关性。然而，由于需求和代码元素往往采用不同的词汇表，需求会使用一些领域相关的词汇，而代码则会用一些专业术语，词汇缩写等。这就使得描述同一功能的两软件制品之间可能存在单词失配(Vocabulary Mismatch)问题，导致一些相关候选追踪线索排在列表底部。最终导致此类方法的精度有限，难以支撑日常实践。

\begin{table}[htbp]
\centering
\caption{基于信息检索的候选追踪线索排序表}
\label{T:IRCandidateListInIntroduction}
\begin{tabular}{@{}llll@{}}
\toprule
   class                   &    req     &   score   &    isTrace  \\
   \midrule
   UpdateCodesListAction   &    UC15    &   0.3524  &       X     \\
   UpdateNDCodesListAction &    UC15    &   0.3124  &       X     \\
   DrugCodesDAO            &    UC15    &   0.2418  &       X     \\
   editDrugCodes\_jsp       &    UC15    &   0.2112  &      X     \\
   editNDCInteractions\_jsp &    UC15    &   0.1816  &             \\
   editNDCodes\_jsp         &    UC15    &   0.1238  &      X     \\
   DCBeanValidator         &    UC15    &   0.1045  &       X     \\
   DrugInteractionAction   &    UC15    &   0.0953  &             \\
   AuthDAO                 &    UC15    &   0.0682  &             \\
   NDCodesDAO              &    UC15    &   0.0487  &       X     \\
   viewResult\_jsp          &    UC15    &   0.0031  &       \\
   \bottomrule
 \end{tabular}
\end{table}


针对该问题，研究者在不同角度引入了多种增强策略（enhancing strategy）。当前领域内主流的策略分为两种：一种是在信息检索基础上加入了代码依赖信息（例如函数调用，继承关系）~\cite{mcmillan2009combining,Kuang2017closeness}，该方法的思想一个需求往往是由多个代码元素通过相互调用协作完成。所以，对于与给定需求文本相似度比较大的代码元素，增加与其存在代码依赖的其它代码元素与该需求的相似度值能够弥补单词失配带来的消极影响。使得一些原本位于列表底部的候选追踪线索在列表中的位置得到提升。我们之前的工作~\cite{Kuang2017closeness}对代码元素之间的代码依赖关系进行了量化，使得能够对代码依赖进行更好的利用。然而，此类方法严重依赖信息检索的结果。如果一些相似度较大的候选追踪线索本身就是无关的，此时列表底部与其存在代码依赖的代码元素对应的追踪线索往往也是无关的，但此时它们的相似度值会被增加即它们在列表中的位置可能得到提升。这就会引入更多的错误对整个候选追踪列表造成污染。另一种增强策略是在信息检索基础上加入用户反馈信息（user feedback）~\cite{hayes2006advancing,panichella2013and,cleland2010machine,Guo2017deep}。根据用户对一些候选追踪线索的判断结果（用户反馈）调整余下候选追踪线索的相似度值。Hayes 等人提出要求用户迭代式判断追踪线索的有效性，然后根据用户反馈更改查询语句（在本文中是需求）的单词权重~\cite{hayes2006advancing}，从而改变改需求与余下类组成候选追踪线索的相似度值。
Panichella等人提出一种同时使用用户反馈和代码依赖的软件可追踪生成方法~\cite{panichella2013and}，该方法要求用户遍历整张信息检索方法得到的候选追踪列表，并对每条候选追踪线索的相关性做出判断。只有当前候选追踪线索被判定相关的时才提升与其存在代码依赖的代码元素对应候选线索的相似度值。与以上两者迭代式方法不同，Guo等人利用深度学习处理需求到代码的软件可追踪性问题，该方法需要用户先对55\%的候选追踪线索有效性做出判断，然后用其中45\%的已判断候选追踪线索作为训练集，剩下10\%的已判断候选追踪线索用来对通过训练集得到模型进行优化，然后对剩下45\%的未判断候选追踪线索进行处理。可以看出此类方法往往需要大量的用户反馈信息，在实际中可操作性不强。


此外，当前用于验证软件可追踪性有效性的实验系统，大多是由开发人员手工标注和维护需求到代码追踪关系的小型软件系统。例如，领域内常用的数据集iTrust系统最初用来作为学生软件测试课程的项目~\cite{coest,Massey2008iTrust}。
然而这和日常实践中的软件系统差距比较大。这也造成有些理论上证明有效的方法在实际日常实践中表现不理想~\cite{Wohlin2012Industry,Cleland-Huang2015Industrial}。当前领域内缺乏公开的用于日常实践的软件可追踪数据集~\cite{Antoniol2017Ten}，因此用被广泛用于日常实践的软件系统来验证软件可追踪方法的有效性是领域内面临的挑战之一。

总的来说，已有工作已经取得重大突破，但是仍有两个工作需要解决：（1）如何在利用少量的用户反馈得到相对改高精度的候选追踪显示列表；（2）如何获取日常实践中的软件系统可追踪数据集，用其验证软件可追踪方法的有效性和实用性。
\section{研究思路}
通过对上述已有工作的分析，接下来我们逐步形成如下研究思路：（1）通过代码依赖紧密度分析识别系统功能紧密的代码元素。一个给定需求通常是由一组交互紧密的代码元素协作实现，而不是随机散步在代码各处~\cite{burgstaller2010understanding}。我们通过引入代码依赖紧密度量化代码元素之间通过代码依赖的交互程度，并将其交互紧密的代码元素放到同一个代码域中。这使得位于同一个代码域的代码元素相互协作共同完成一个需求，并且代码域作为用户反馈的切入点，有效减少了用户反馈的数量。（2）引入用户反馈来防止直接使用代码依赖造成的列表污染问题。具体来说，对于一个给定需求，取代码域中一个有代表性的代码元素交由用户验证与需求相关性。只有当用户反馈结果为该代码元素和需求相关时，才会调整域内其它类和域外相关类对应候选追踪线索的相似度值。（3）针对域内和域外代码元素设置不同的优化策略。对于域内类对应候选线索相似度值的调整，我们考虑两个因素：域内代码元素的个数和域内其它代码元素与代表代码元素之间路径长度。我们认为域内代码元素越少，则域内代码元素之间的系统功能关系越紧密。我们定义路径长度的值为两代码元素之间所有有效路径上各代码依赖紧密度累乘的最大值。对于域外代码元素，我们根据其到域内代表代码元素之间的距离优化其对应追踪线索的相似度值。从而改善整个候选列表的排序。

我们需要高质量的基于日常生活实践的可追踪数据集来验证我们方法的有效性和实用性。然而，当前领域内公开的需求到代码可追踪数据集通常是一些小型系统。因此，我们整理了被广泛应用于日常实践的开源软件可追踪数据集。我们的实验系统由一个被领域内广泛用于软件可追踪方法验证的高质量数据集iTrust和三个被广泛用于日常生活实践的开源软件系统Maven、Pig和Infinispan组成。对于实验系统中由代码托管平台管理的开源软件，其代码托管平台记录了针对其issue-tracking工具描述软件行为变更的代码提交信息。由此，我们组织了软件行为变更（需求）到代码提交（代码元素）的相关性。此外，我们的方法需要高质量的代码依赖信息，我们通过运行软件系统自带的用于验证自身功能的测试用例得到代码依赖子集进而通过合并得到代码依赖集。实验表明，我们的方法只需少量的（3.5\%）用户反馈信息在精度上即可显著优于基线方法。

为了将我们的方法应用到日常生活实践中，我们结合用户使用习惯实现了软件可追踪查询工具并集成了我们提出的结合用户反馈和代码依赖的软件可追踪生成方法。该工具类似一个搜索引擎，返回与给定需求具有相关性的代码元素。在方法中的用户验证追踪线索相关性阶段，工具提供大量的辅助信息帮助用户高效的做出正确的验证。对于被验证候选线索对应的代码元素，工具提供了与之相关的代码依赖拓扑图，并用不同的颜色表达图中其它代码元素与该代码元素的代码依赖紧密程度。此外，用户还能很方便的查看已被验证的与当前代码元素具有相关性的其它需求，当前代码元素与需求的相似度值。在需求文本中出现过的单词在代码元素文本中会高亮线索等。以上多种辅助信息有效节省了用户的验证时间并提高了用户验证的正确率。

\section{本文工作}
综上所述，本文完成了以下工作：
\begin{enumerate}
  \item 结合代码依赖紧密度分析和用户反馈的软件可追踪性生成方法。我们提出了一种结合了代码紧密度分析和用户反馈的软件可追踪生成方法CLUSTER(CLoseness-and-USer-feedback-based TracEability Recovery)。该方法有效利用了代码依赖紧密度和用户反馈两部分信息，一方面通过设置代码紧密度阈值划分代码域，使得功能紧密的代码元素位于同一个代码域中；另一方面，将各代码域中有代表性的代码元素交由用户判断与需求相关性，根据用户反馈信息调整相关代码元素对应候选追踪线索的相似度值。
  \item 实验数据组织及方法验证。我们用一个被领域内广泛用于可追踪方法验证的高质量数据集和三个被广泛应用于日常实践的开源系统验证了我们方法的有效性和实用性。并且，我们通过对开源软件在issue-tracking工具上的行为信息进行分析整理，组织了其需求到代码的追踪关系。我们通过运行开源系统自带的用于验证系统功能的测试用例动态捕获我们方法所需的代码依赖。

  \item 基于代码依赖和用户反馈的软件可追踪生成工具的设计与实现。为了将我们的方法应用到日常实践中，我们设计并实现软件可追踪生成工具，并集成了我们基于代码依赖紧密度分析和用户反馈的软件可追踪生成方法。

\end{enumerate}

\section{本文组织}
针对当前软件可追踪生成领域存在的问题，本文研究需求到代码元素可追踪性生成这一问题。综合考虑代码依赖和用户反馈两部分信息，以尽可能减少用户参与并提高结果精度。从需求到代码元素可追踪生成的场景出发，研究了代码依赖和用户反馈如何有效协作提高候选追踪列表精度。论文总共六章，第一章作为绪论，提出了本文的研究背景及概要结构，其余五章的概要内容总结如下：

第二章主要介绍了与本文研究相关的概念与工作，包括软件可追踪生成，结合代码依赖关系，用户反馈和信息检索的相关技术。

第三章介绍基于代码依赖和用户反馈的软件可追踪生成方法。介绍如何通过代码依赖紧密度阈值划分代码域，使得功能紧密的代码元素位于同一个代码域中以及如何结合代码域和用户反馈提高软件可追踪生成精度。此外我们用一个案例对我们的方法步骤进行了更详细的描述。

第四章介绍了我们对于结合代码依赖和用户反馈的软件可追踪生成方法的实验数据组织和实验结果分析。我们在四个研究案例下设计实验，验证了我们方法的有效性和实用性。我们通过分析开源项目在issue-tracking的软件行为信息组织了其需求到代码的追踪数据，通过运行其自带用于验证自身功能的测试集动态捕获到了我们方法所需要的代码依赖。
%并且，我们提出了通过运行测试集获得代码依赖的方法。此外，本文详细介绍了我们对实际工业界软件系统可追踪性数据集的获取过程。

第五章介绍了软件可追踪生成工具的设计实现，并结合一个案例阐述了其在实际软件活动过程中的应用。

第六章是对全文工作的总结，并基于我们已有的研究内容展望未来工作。

\begin{comment}
在本节中，我们将会讨论软件可追踪生成领域的现状，主要包括当前软件可追踪生成的一些方法。
我们所关注的软件可追踪性是需求到代码元素的可追踪性。

通过对上述已有工作的分析，接下来我们逐步形成如下研究思路：（1）通过代码依赖紧密度分析识别系统功能紧密的代码元素。一个给定需求通常是由一组交互紧密的代码元素协作实现，而不是随机散步在代码各处~\cite{burgstaller2010understanding}。我们通过引入代码依赖紧密度量化代码元素之间通过代码依赖的交互程度，并将其交互紧密的代码元素放到同一个代码域中。这使得位于同一个代码域的代码元素相互协作共同完成一个需求，并且代码域作为用户反馈的切入点，有效减少了用户反馈的数量。
（2）引入用户反馈来防止直接使用代码依赖造成的列表污染问题。具体来说，我们引入代码依赖紧密度对代码元素之间通过代码依赖的交互程度进行量化，同时通过设置代码依赖紧密度阈值将功能紧密的代码元素放到同一个代码域中。我们用代码域作为用户反馈的切入点，代码域的引入有效减少了用户反馈的数量。对于一个给定需求，只需取一个代码域中有代表性的代码元素交由用户判断与需求相关性即可。（3）根据该判断结果调整域内和域外相关类对应候选线索的相似度值，从而改善整个候选列表的排序。
\end{comment}
